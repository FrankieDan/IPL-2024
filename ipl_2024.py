# -*- coding: utf-8 -*-
"""IPL 2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iKkawfi4DGQrONx40obdOGyc_jycTNXp
"""

import kagglehub

path = kagglehub.dataset_download("aryanverma99/ipl-2024-player-lifetime-dataset")

import pandas as pan
import os

# Load all CSVs in the dataset path
data_files = [f for f in os.listdir(path) if f.endswith('.csv')]
df = {file: pan.read_csv(os.path.join(path, file)) for file in data_files}

# Check what files are in the dataset
print(df.keys())

# Show preview of one DataFrame
df[data_files[0]].head()

df1 = df[data_files[0]]  # Accessing the first file in the list

print(df1.info())
print(df1.describe())
print(df1.isnull().sum())

top_batsmen = df1.sort_values(by='Runs_Scored', ascending=False).head(10)
runs = top_batsmen['Runs_Scored']
labels = top_batsmen['Player_Name']

# Donut chart
fig, ax = plt.subplots(figsize=(8, 8))
wedges, texts, autotexts = ax.pie(
    runs,
    labels=labels,
    autopct='%1.1f%%',
    startangle=140,
    pctdistance=0.85
)
# Draw a circle in the middle to make it a donut
centre_circle = plt.Circle((0, 0), 0.70, fc='white')
fig.gca().add_artist(centre_circle)

plt.title("Top 10 Run Scorers - Share of Runs")
plt.tight_layout()
plt.show()

df1.columns = df1.columns.str.strip()

import numpy as np

# Ensure 'Batting_Strike_Rate' is numeric and handle non-numeric values (e.g., 'N/A', '-', etc.)
df1['Batting_Strike_Rate'] = pan.to_numeric(df1['Batting_Strike_Rate'], errors='coerce')

# Ensure 'Runs_Scored' is numeric and handle non-numeric values (e.g., 'N/A', '-', etc.)
df1['Runs_Scored'] = pan.to_numeric(df1['Runs_Scored'], errors='coerce')

# Now calculate impact_score
df1['impact_score'] = (df1['Batting_Strike_Rate'] * df1['Runs_Scored']) / 100

df1['predicted_runs_2024'] = df1['Runs_Scored'] * np.random.uniform(0.75, 1.25, len(df1))

import numpy as np
import pandas as pan
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error
# Print the available columns to check for the correct name
print(df1.columns)
print(df1.columns.tolist())
df1.columns = df1.columns.str.strip().str.replace(' ', '_')
# Define features, ensure correct column names
features = ['Runs_Scored', 'Matches_Batted', 'Batting_Strike_Rate', 'Batting_Average', 'impact_score']  # Corrected feature name
X = df1[features]
y = df1['predicted_runs_2024']

# Remove rows with NaN values in either features or target variable
X = X.dropna()  # Drop rows with NaN in features
y = y[X.index]  # Keep only the target values corresponding to the remaining rows in X

# Split data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train model
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Evaluate
y_pred = model.predict(X_test)
# Calculate MSE and then take the square root to get RMSE
mse = mean_squared_error(y_test, y_pred)  # Calculate MSE
rmse = np.sqrt(mse)  # Calculate RMSE from MSE
print(f"RMSE: {rmse:.2f}")

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(10, 6))
ax = sns.barplot(data= top_predicted, y='Player_Name', x='predicted_runs_2024', palette='coolwarm')
plt.title("Top 10 Predicted Run Scorers - IPL 2024")
plt.xlabel("Predicted Runs")
plt.ylabel("Player Name")

# Add values to bars
for i, v in enumerate(top_predicted['predicted_runs_2024']):
    ax.text(v + 5, i, f'{int(v)}', color='black', va='center')

plt.tight_layout()
plt.show()

!pip install streamlit

# app.py
!pip install streamlit
import streamlit as st
import pandas as pan
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Load the data
@st.cache_data
def load_data():
    # Assuming your DataFrame is named 'df1' based on previous code
    df = df1.copy()  # Create a copy to avoid modifying the original DataFrame
    # Add a column for 2024 predicted runs if it doesn't exist
    if '2024_predicted_runs' not in df.columns:
        df['2024_predicted_runs'] = df['predicted_runs_2024']
    return df

df = load_data()


st.title("üèè IPL 2024 Player Performance Predictor")

# Sidebar: Player selector
player_list = df['Player_Name'].dropna().unique()
selected_player = st.sidebar.selectbox("Select a Player", sorted(player_list))

# Player info
player_data = df[df['Player_Name'] == selected_player].iloc[0]

st.subheader(f"üìã Stats for: {selected_player}")
st.write(f"**Matches Batted:** {player_data['Matches_Batted']}")
st.write(f"**Runs Scored:** {player_data['Runs_Scored']}")
st.write(f"**Strike Rate:** {player_data['Batting_Strike_Rate']}")
st.write(f"**Batting Consistency:** {round(player_data['batting_consistency'], 2)}")
st.write(f"**Impact Score:** {round(player_data['impact_score'], 2)}")
st.markdown(f"### üéØ Predicted Runs in 2024: `{int(player_data['2024_predicted_runs'])}`")

# Top predicted run scorers
st.subheader("üî• Top 10 Predicted Run Scorers - IPL 2024")
top_10 = df.sort_values(by='2024_predicted_runs', ascending=False).head(10)

fig, ax = plt.subplots()
sns.barplot(data=top_10, x='2024_predicted_runs', y='Player_Name', ax=ax)
ax.set_title("Top 10 Predicted Scorers")
ax.set_xlabel("Predicted Runs")
ax.set_ylabel("Player")
st.pyplot(fig)

#Radar Chart for Player Profile

import matplotlib.pyplot as plt
import numpy as np

def plot_radar(player_data, player_name):
    # Radar chart stats (scale them if necessary)
    categories = ['Runs', 'Average', 'Strike Rate', 'Consistency', 'Impact']
    values = [
        player_data['Runs_Scored'],
        player_data['Batting_Average'],
        player_data['Batting_Strike_Rate'],
        player_data['batting_consistency'],
        player_data['impact_score']
    ]

    # Convert values to numeric, handling potential errors
    values = [pan.to_numeric(v, errors='coerce') for v in values]

    # Normalize values to 0‚Äì1 for fair comparison
    max_values = [6000, 60, 200, 100, 1500]  # Approx upper bounds
    # Handle potential NaN values after conversion
    values = [v / m if not np.isnan(v) else 0 for v, m in zip(values, max_values)]

    # Repeat first value to close the radar loop
    values += values[:1]
    angles = np.linspace(0, 2 * np.pi, len(categories), endpoint=False).tolist()
    angles += angles[:1]

    # Plotting
    fig, ax = plt.subplots(figsize=(6, 6), subplot_kw=dict(polar=True))
    ax.plot(angles, values, linewidth=2, linestyle='solid')
    ax.fill(angles, values, alpha=0.25)

    ax.set_theta_offset(np.pi / 2)
    ax.set_theta_direction(-1)
    ax.set_thetagrids(np.degrees(angles[:-1]), categories)
    ax.set_title(f"{player_name} - Performance Profile", size=14)
    ax.set_ylim(0, 1)

    return fig

player_data = df[df['Player_Name'] == 'Virat Kohli'].iloc[0]
fig = plot_radar(player_data, 'Virat Kohli')
plt.show()